#!/bin/bash

set -eo pipefail

CACHE_FROM="${CACHE_FROM:-}"

# Get absolute path to current script parent dir and save to DIR
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
    DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"

set -x

version="${1:-latest}"

cd "$DIR"

. git.env

./build-dockerfile

cd ../src

# if in a CI environment, verify regenerating files resulted in no differences
if [ "${CI}" == "true" ] && [ -n "$(git status --porcelain)" ]; then
    echo "cowardly refusing to build: looks like the dockerfile needs to be regenerated and results need to be commited"
    exit 1
fi

BRANCH="$(git symbolic-ref --short HEAD 2>/dev/null || true)"
BRANCH="${BRANCH:-$DETACHED_BRANCH}"

DOCKER_IMAGE="josephcopenhaver/docker-images:${BRANCH#*/}-$version"

HASHES1=$(docker images -q "$DOCKER_IMAGE" | sort -u)

DOCKER_BUILD_PLATFORM="${DOCKER_BUILD_PLATFORM:-${DOCKER_PLATFORM:-${DOCKER_DEFAULT_PLATFORM:-linux/$(uname -m)}}}"

docker buildx build "--platform=$DOCKER_BUILD_PLATFORM" \
    $( test -z "$CACHE_FROM" || printf -- '--cache-from %s' "$CACHE_FROM" ) \
    -t "$DOCKER_IMAGE" \
    .

set +x
if [ -n "$HASHES1" ]; then
    HASHES2="\n$(docker images -q "$DOCKER_IMAGE" | sort -u)\n"
    REMOVABLES=""
    HASH=''
    while read HASH; do
        if [[ "\n$HASH\n" == *"$HASHES2"* ]]; then
            continue
        fi
        [ -z "$REMOVABLES" ] && REMOVABLES="$HASH" || REMOVABLES="${REMOVABLES} ${HASH}"
    done < <(printf '%s\n' "$HASHES1")
    [ -z "$REMOVABLES" ] || (
        set -x
        docker rmi $REMOVABLES || true
        echo 'Unused images could still exist. You should run "docker image prune"'
    )
fi
