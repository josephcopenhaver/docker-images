#!/bin/bash

# if you modify this file, please consider also modifying exec

set -eo pipefail

version="${1:-latest}"
suffix="$2"
[ -n "$suffix" ] && suffix="-$suffix"

# Get absolute path to current script parent dir and save to DIR
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
    DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"

. "$DIR/git.env"

BRANCH="$(git symbolic-ref --short HEAD 2>/dev/null || true)"

set -x

BRANCH="${BRANCH:-$DETACHED_BRANCH}"

img="josephcopenhaver/docker-images:${BRANCH#*/}-$version"
name="josephcopenhaver-${img#*:}$suffix"
ssh_port="${SSH_PORT:-0}" # set to something other than zero if you need to have a static port

bash "$DIR/init"
. "$DIR/.env"

docker run --init --rm -d \
    -p 127.0.0.1:$ssh_port:22 \
    --name "$name" \
    --security-opt seccomp:unconfined \
    --cap-add sys_admin \
    --privileged=true \
    -v "$STATE_DIR/.bash_history:/home/vagrant/.bash_history" \
    -v "$STATE_DIR/.bashrc.local:/home/vagrant/.bashrc.local" \
    $(test ! -s "$DIR/.docker-options" || eval "printf '%s' \"$(cat "$DIR/.docker-options" | sed -E 's/^\s*#.*$//' | tr '\n' ' ')\"" ) \
    "$img"

set +x

prompt="Kill container: $name ? (y/n)"

if [[ $ssh_port -eq 0 ]]; then
    # find real local ssh port
    ssh_port="$(docker inspect --format '{{(index (index .NetworkSettings.Ports "22/tcp") 0).HostPort}}' "$name")"
    if [ -z "$ssh_port" ]; then
        echo "Failed to get ssh port"
        exit 1
    fi
fi

function control_c() {
    set -x
    docker stop "$name"
    exit 0
}

trap control_c SIGINT
trap control_c SIGTERM

remote_keyfile_dir='$HOME/.ssh.vagrant' # intentionally escaping $HOME variable
ssh_host='127.0.0.1'
ssh_keyfile="$DIR/.ssh_key"
ssh_configfile="$DIR/.state/.ssh_config"
connect_max_tries=10
connect_attempt=0

# Note on wsl a mounted filesystem has filed permissions set permanently to *777
#
# if on wsl then change keyfile dir under the user's home directory
install -m 0600 /dev/null "$ssh_keyfile"
if [[ "$(stat -c '%a' "$ssh_keyfile")" != *"600" ]]; then
    keyfileCacheDir="$HOME/.josephcopenhaver/.docker-images"
    mkdir -p "$keyfileCacheDir"
    ssh_keyfile="$keyfileCacheDir/$(printf '%s' "$ssh_keyfile" | base64 -w0 | sed -r 's/\+/-/g; s/\//_/g; s/=+$//').pem"
    install -m 0600 /dev/null "$ssh_keyfile"
    if [[ "$(stat -c '%a' "$ssh_keyfile")" != *"600" ]]; then
        echo "failed to find a keyfile dir that would let permissions be set to 0600 properly: $ssh_keyfile"
        exit 1
    fi
fi

install -m 0600 /dev/null "${ssh_configfile}"
cat << EOF > "${ssh_configfile}"
Host ${ssh_host}
  User vagrant
  Port ${ssh_port}
  UserKnownHostsFile /dev/null
  PasswordAuthentication no
  IdentitiesOnly yes
  IdentityFile ${ssh_keyfile}
  StrictHostKeyChecking no
EOF

echo ""
echo "SSH config file: ${ssh_configfile}"
echo ""

while :; do
    loop_start_seconds="$SECONDS"
    connect_attempt=$(( $connect_attempt + 1 ))
    if [[ $connect_attempt -gt $connect_max_tries ]]; then
        echo "Failed to connect after $connect_max_tries attempts, something is wrong"
        exit 1
    fi
    
    # ensure target ssh keyfile is empty as this will be used to indicate a successful fetch or not
    install -m 0600 /dev/null "$ssh_keyfile"

    set +eo pipefail
    docker exec -it -u vagrant:vagrant "$name" bash -c '(test -f "'"$remote_keyfile_dir"'/id_rsa" || ssh-keygen -t rsa -b 4096 -f "'"$remote_keyfile_dir"'/id_rsa" -q -N "" && install -m 0600 "'"$remote_keyfile_dir"'/id_rsa.pub" "'"$remote_keyfile_dir"'/authorized_keys") >/dev/null 2>/dev/null && cat "'"$remote_keyfile_dir"'/id_rsa" | base64 -w0' | base64 -d >> "$ssh_keyfile"
    set -eo pipefail
    
    [ ! -s "$ssh_keyfile" ] \
        && ( [[ $(( $SECONDS - $loop_start_seconds )) -ge 1 ]] || sleep 1 ) \
        && continue

    # You cannot use the exit code of ssh to determine if a connection was successful.
    # By default ssh exits with the error code of the last command ran in the remote's
    # shell. This is why I prefer this alias: exit='echo bye && \exit' in the remote shell

    set +eo pipefail
    ssh \
        -F "${ssh_configfile}" \
        $(test ! -s "$DIR/.ssh-options" || (cat "$DIR/.ssh-options" | sed -E 's/^\s*#.*$//' | tr '\n' ' ') ) \
        "${ssh_host}"
    rc=$?
    set -eo pipefail
    
    if [[ $rc -eq 0 ]]; then
        break
    fi
    [[ $(( $SECONDS - $loop_start_seconds )) -ge 1 ]] || sleep 1
done

# calling reset while within a visual studio code terminal window deletes output history
# best to just avoid making a decision for the developer
# reset
echo "$prompt"

while read -r response; do
    if [[ "$response" =~ ^(y|Y|n|N)$ ]]; then
        if [[ "$response" =~ ^(y|Y)$ ]]; then
            control_c
        else
            break
        fi
    fi
    echo "$prompt"
done
